# ТЕХНІЧНИЙ ОПИС РОБОТИ СИСТЕМИ

## Лабораторна робота №2 - Bluetooth зв'язок ESP32 з Android

---

## 1. АРХІТЕКТУРА СИСТЕМИ

### 1.1 Загальна схема

Система складається з двох основних компонентів:

```
┌─────────────────────────────────────────────────────────────┐
│                    ESP32 (Сервер)                           │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │   Sensor     │→ │   JSON       │→ │  Bluetooth   │      │
│  │  Generator   │  │  Formatter   │  │   Serial     │      │
│  └──────────────┘  └──────────────┘  └──────┬───────┘      │
└─────────────────────────────────────────────┼──────────────┘
                                               │
                                    Bluetooth Classic
                                    (Serial Port Profile)
                                               │
┌─────────────────────────────────────────────┼──────────────┐
│                    Android (Клієнт)          │              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────▼───────┐     │
│  │  Bluetooth   │→ │   JSON       │→ │   Data       │     │
│  │   Adapter    │  │   Parser     │  │  Processor   │     │
│  └──────────────┘  └──────────────┘  └──────┬───────┘     │
│                                               │             │
│  ┌──────────────┐  ┌──────────────┐  ┌──────▼───────┐     │
│  │   History    │← │     UI       │← │  Statistics  │     │
│  │   Manager    │  │  Components  │  │  Calculator  │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. ПРОТОКОЛ BLUETOOTH CLASSIC

### 2.1 Що таке Bluetooth Classic?

Bluetooth Classic (також відомий як Bluetooth BR/EDR) - це оригінальний протокол Bluetooth, який використовується для передачі великих обсягів даних на короткі відстані (до 10 метрів).

### 2.2 Serial Port Profile (SPP)

SPP - це профіль Bluetooth, який емулює серійний порт. Це дозволяє:

- Передавати дані як через звичайний Serial порт
- Використовувати прості функції read/write
- Не потрібно знати деталі протоколу Bluetooth

### 2.3 UUID для SPP

```
UUID: 00001101-0000-1000-8000-00805F9B34FB
```

Це стандартний UUID для Serial Port Profile, який використовується для створення RFCOMM з'єднання.

---

## 3. РОБОТА ESP32

### 3.1 Ініціалізація Bluetooth

```cpp
BluetoothSerial SerialBT;
SerialBT.begin("ESP32_MagneticSensor");
```

**Що відбувається:**

1. ESP32 ініціалізує Bluetooth модуль
2. Встановлює ім'я пристрою "ESP32_MagneticSensor"
3. Стає видимим для інших пристроїв
4. Створює серійний порт через Bluetooth

### 3.2 Генерація даних

**Алгоритм:**

1. Використовується `random()` для генерації випадкового числа
2. Діапазон: -10000 до 10000 (цілі числа)
3. Ділення на 100 для отримання значення з 2 знаками після коми
4. Результат: -100.00 до +100.00 мкТл

**Визначення напрямку:**

- Якщо значення >= 0 → "N" (Північ)
- Якщо значення < 0 → "S" (Південь)

### 3.3 Формування JSON

**Формат:**

```json
{ "magnetic": 45.7, "direction": "N" }
```

**Процес:**

1. Створюється рядок з JSON структурою
2. Значення форматується з 2 знаками після коми
3. Напрямок додається як рядок

### 3.4 Відправка даних

```cpp
SerialBT.println(jsonPacket);
```

**Особливості:**

- `println()` додає символ нового рядка `\n`
- Дані відправляються через RFCOMM канал
- Передача асинхронна (не блокує виконання)

### 3.5 Таймер

```cpp
if (millis() - lastTime >= 1000) {
    // Відправка даних
}
```

**Принцип роботи:**

- `millis()` повертає час з моменту старту (в мілісекундах)
- Перевіряється різниця між поточним часом та часом останньої передачі
- Якщо різниця >= 1000 мс (1 секунда), відправляються дані

---

## 4. РОБОТА ANDROID ДОДАТКУ

### 4.1 Дозволи

**AndroidManifest.xml:**

```xml
<uses-permission android:name="android.permission.BLUETOOTH" />
<uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
<uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
<uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
```

**Runtime дозволи (Android 12+):**

- `BLUETOOTH_SCAN` - для пошуку пристроїв
- `BLUETOOTH_CONNECT` - для підключення

### 4.2 Пошук пристроїв

**Процес:**

1. Отримання BluetoothAdapter
2. Перевірка чи увімкнено Bluetooth
3. Запуск сканування: `adapter.startDiscovery()`
4. Отримання списку пристроїв через BroadcastReceiver
5. Фільтрація за іменем "ESP32_MagneticSensor"

**BroadcastReceiver слухає події:**

- `BluetoothDevice.ACTION_FOUND` - знайдено пристрій
- `BluetoothAdapter.ACTION_DISCOVERY_FINISHED` - сканування завершено

### 4.3 Підключення

**Кроки:**

1. Отримання BluetoothDevice за MAC адресою
2. Створення RFCOMM сокету:
   ```kotlin
   device.createRfcommSocketToServiceRecord(SPP_UUID)
   ```
3. Підключення: `socket.connect()`
4. Отримання InputStream та OutputStream
5. Запуск потоку для читання даних

### 4.4 Читання даних

**Алгоритм:**

```kotlin
Thread {
    val buffer = ByteArray(1024)
    while (isConnected) {
        val bytes = inputStream.read(buffer)
        val data = String(buffer, 0, bytes)
        processData(data)
    }
}
```

**Особливості:**

- Читання в окремому потоці (не блокує UI)
- Буфер 1024 байти для отримання даних
- Дані можуть приходити частинами або кілька пакетів разом
- Потрібно розділяти по символу `\n`

### 4.5 Парсинг JSON

**Використання Gson:**

```kotlin
val gson = Gson()
val data = gson.fromJson(jsonString, MagneticData::class.java)
```

**Обробка помилок:**

- Try-catch для невалідного JSON
- Перевірка на null
- Логування помилок

### 4.6 Обробка даних

#### 4.6.1 Статистика

**Середнє значення:**

```kotlin
val average = data.average()
```

**Мінімум/Максимум:**

```kotlin
val min = data.minOrNull()
val max = data.maxOrNull()
```

#### 4.6.2 Швидкість зміни

**Формула:**

```
rateOfChange = currentValue - previousValue
```

Оскільки дані приходять кожну секунду, це і є швидкість зміни в мкТл/с.

#### 4.6.3 Тренд

**Алгоритм:**

1. Беремо останні 10 значень
2. Ділимо на дві половини
3. Обчислюємо середнє кожної половини
4. Порівнюємо:
   - Якщо друга половина > першої → зростання
   - Якщо друга половина < першої → спадання
   - Інакше → стабільний

**Порогова величина:** 5 мкТл (5% від діапазону)

### 4.7 Візуалізація

#### 4.7.1 Текстовий вивід

- Поточне значення: `45.7 мкТл`
- Напрямок: `Напрямок: N`
- Статистика: багаторядковий текст

#### 4.7.2 Графік (MPAndroidChart)

**Структура:**

- LineChart для відображення лінійного графіка
- Entry (x, y) - точка на графіку
- LineDataSet - набір даних
- LineData - дані для графіка

**Оновлення:**

1. Додавання нової точки: `Entry(xValue, magneticValue)`
2. Видалення старих точок (якщо > 100)
3. Оновлення графіка: `chart.invalidate()`
4. Автопрокрутка до останньої точки

**Налаштування:**

- Ось Y: від -100 до +100 мкТл
- Плавна крива: `CUBIC_BEZIER` mode
- Кольори: синій для лінії та точок

### 4.8 Збереження історії

**Структура:**

```kotlin
data class HistoryEntry(
    val timestamp: Long,    // Час вимірювання
    val magnetic: Float,    // Значення
    val direction: String   // Напрямок
)
```

**Управління:**

- MutableList для зберігання
- Максимум 100 записів
- При перевищенні видаляється найстаріший запис (FIFO)

**Форматування часу:**

```kotlin
SimpleDateFormat("HH:mm:ss", Locale.getDefault())
```

---

## 5. ПОТОК ДАНИХ

### 5.1 Від ESP32 до Android

```
ESP32:
1. Генерація значення (-100..+100 мкТл)
2. Визначення напрямку (N/S)
3. Формування JSON: {"magnetic": 45.7, "direction": "N"}
4. Відправка через SerialBT.println()
   ↓
Bluetooth RFCOMM:
5. Передача через радіоканал
   ↓
Android:
6. Отримання байтів через InputStream
7. Конвертація в String
8. Розділення по \n
9. Парсинг JSON через Gson
10. Створення об'єкта MagneticData
11. Оновлення UI
12. Обчислення статистики
13. Оновлення графіка
14. Збереження в історію
```

### 5.2 Часові характеристики

- **Інтервал передачі:** 1 секунда
- **Розмір пакету:** ~30-40 байт (JSON)
- **Затримка передачі:** < 10 мс (Bluetooth)
- **Обробка на Android:** < 50 мс
- **Оновлення UI:** < 16 мс (60 FPS)

---

## 6. ОБРОБКА ПОМИЛОК

### 6.1 ESP32

**Можливі проблеми:**

- Bluetooth не ініціалізовано
- Немає підключених клієнтів
- Переповнення буфера

**Рішення:**

- Перевірка `SerialBT.hasClient()` перед відправкою
- Використання `println()` замість `print()` для автоматичного flush

### 6.2 Android

**Можливі проблеми:**

- Bluetooth вимкнено
- Пристрій не знайдено
- Помилка підключення
- Втрата з'єднання
- Невалідний JSON

**Рішення:**

- Перевірка стану Bluetooth перед операціями
- Try-catch для всіх операцій з Bluetooth
- Обробка IOException при читанні/записі
- Валідація JSON перед парсингом
- Callback для повідомлення про зміну стану

---

## 7. ОПТИМІЗАЦІЯ

### 7.1 ESP32

- Використання `millis()` замість `delay()` для неблокуючого таймера
- Мінімальна затримка в loop() (10 мс)
- Перевірка наявності клієнта перед відправкою

### 7.2 Android

- Читання в окремому потоці
- Оновлення UI через `runOnUiThread()`
- Обмеження кількості точок на графіку (100)
- Використання RecyclerView для історії (якщо багато записів)

---

## 8. РОЗШИРЕНІ МОЖЛИВОСТІ

### 8.1 Двосторонній зв'язок

**Відправка команди з Android:**

```kotlin
bluetoothService.sendCommand("INTERVAL:2000\n")
```

**Обробка на ESP32:**

```cpp
if (SerialBT.available()) {
    String command = SerialBT.readString();
    // Парсинг команди та зміна інтервалу
}
```

### 8.2 Енергозбереження

**ESP32:**

- Вимкнення при відсутності підключення
- Зниження частоти при стабільних значеннях
- Режим глибокого сну між передачами

**Android:**

- Зупинка сканування після підключення
- Вимкнення Bluetooth при закритті додатку

---

## 9. ТЕСТУВАННЯ

### 9.1 Тестування ESP32

1. Перевірка в Serial Monitor:

   - Вивід JSON пакетів
   - Частота відправки (1 раз/сек)

2. Перевірка підключення:
   - Видимість в списку пристроїв
   - Успішне підключення

### 9.2 Тестування Android

1. Пошук пристроїв:

   - Відображення ESP32 в списку
   - Правильне ім'я пристрою

2. Підключення:

   - Успішне підключення
   - Відображення статусу

3. Отримання даних:

   - Оновлення значень
   - Правильний парсинг JSON
   - Відображення на графіку

4. Статистика:

   - Правильні обчислення
   - Оновлення в реальному часі

5. Історія:
   - Збереження 100 записів
   - Правильне форматування

---

## 10. ВИСНОВКИ

Система реалізує повний цикл:

1. **Генерація даних** на ESP32
2. **Передача через Bluetooth** у форматі JSON
3. **Приймання та парсинг** на Android
4. **Обробка та аналіз** даних
5. **Візуалізація** в текстовому та графічному вигляді
6. **Збереження історії** вимірювань

Всі компоненти працюють асинхронно та не блокують один одного, що забезпечує плавну роботу системи в реальному часі.
